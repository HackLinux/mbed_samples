Index: rtl/embedded/arm/mbed.pp
===================================================================
--- rtl/embedded/arm/mbed.pp	(revision 0)
+++ rtl/embedded/arm/mbed.pp	(revision 0)
@@ -0,0 +1,142 @@
+
+unit mbed;
+
+{$goto on}
+{$define stm32f103}
+
+interface
+
+implementation
+
+var
+    _data: record end; external name '_data';
+    _edata: record end; external name '_edata';
+    _etext: record end; external name '_etext';
+    _bss_start: record end; external name '_bss_start';
+    _bss_end: record end; external name '_bss_end';
+    _stack_top: record end; external name '_stack_top';
+
+procedure PASCALMAIN; external name 'PASCALMAIN';
+
+procedure _FPC_haltproc; assembler; nostackframe; public name '_haltproc';
+asm
+.Lhalt:
+    b .Lhalt
+end;
+
+procedure _FPC_start; assembler; nostackframe;
+label _start;
+asm
+    .init
+    .balign 16
+
+    .long _stack_top            // stack top address
+    .long _start+1              // 1 Reset
+    .long .LDefaultHandler+1    // 2 NMI
+    .long .LDefaultHandler+1    // 3 HardFault
+    .long .LDefaultHandler+1    // 4 MemManage
+    .long .LDefaultHandler+1    // 5 BusFault
+    .long .LDefaultHandler+1    // 6 UsageFault
+    .long .LDefaultHandler+1    // 7 RESERVED
+    .long .LDefaultHandler+1    // 8 RESERVED
+    .long .LDefaultHandler+1    // 9 RESERVED
+    .long .LDefaultHandler+1    // 10 RESERVED
+    .long .LDefaultHandler+1    // 11 SVCall
+    .long .LDefaultHandler+1    // 12 Debug Monitor
+    .long .LDefaultHandler+1    // 13 RESERVED
+    .long .LDefaultHandler+1    // 14 PendSV
+    .long .LDefaultHandler+1    // 15 SysTick
+    .long .LDefaultHandler+1    // 16 External Interrupt(0)
+    .long .LDefaultHandler+1    // 17 External Interrupt(1)
+    .long .LDefaultHandler+1    // 18 External Interrupt(2)
+    .long .LDefaultHandler+1    // 19 ...
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .globl _start
+    .text
+_start:
+
+    // Copy initialized data to ram
+    ldr r1,.L_etext
+    ldr r2,.L_data
+    ldr r3,.L_edata
+.Lcopyloop:
+    cmp r2,r3
+    ittt ls
+    ldrls r0,[r1],#4
+    strls r0,[r2],#4
+    bls .Lcopyloop
+
+    // clear onboard ram
+    ldr r1,.L_bss_start
+    ldr r2,.L_bss_end
+    mov r0,#0
+.Lzeroloop:
+    cmp r1,r2
+    itt ls
+    strls r0,[r1],#4
+    bls .Lzeroloop
+
+    b PASCALMAIN
+    b _FPC_haltproc
+
+.L_bss_start:
+    .long _bss_start
+.L_bss_end:
+    .long _bss_end
+.L_etext:
+    .long _etext
+.L_data:
+    .long _data
+.L_edata:
+    .long _edata
+.LDefaultHandlerAddr:
+    .long .LDefaultHandler
+    // default irq handler just returns
+.LDefaultHandler:
+    mov pc,r14
+end;
+
+end.
+
Index: rtl/embedded/arm/arm_bare.pp
===================================================================
--- rtl/embedded/arm/arm_bare.pp	(revision 0)
+++ rtl/embedded/arm/arm_bare.pp	(revision 0)
@@ -0,0 +1,55 @@
+
+unit arm_bare;
+
+{$goto on}
+
+  interface
+
+  implementation
+
+    procedure PASCALMAIN; external name 'PASCALMAIN';
+
+    procedure _FPC_haltproc; assembler; nostackframe; public name '_haltproc';
+      asm
+      .Lhalt:
+        b .Lhalt
+      end;
+
+    var
+      _data: record end; external name '_data';
+      _bss_start: record end; external name '_bss_start';
+      _bss_end: record end; external name '_bss_end';
+      _stack_top: record end; external name '_stack_top';
+
+    procedure _FPC_start; assembler; nostackframe;
+      label
+        _start;
+      asm
+        // code derived from phillips appnote 10254
+        .init
+        .align 16
+        .globl _start
+        b   _start
+    _start:
+        ldr sp,.L_stack_top
+        // clear onboard ram
+        ldr r1,.L_bss_start
+        ldr r2,.L_bss_end
+        mov r0,#0
+.Lzeroloop:
+        cmp r1,r2
+        strls r0,[r1],#4
+        bls .Lzeroloop
+
+        bl PASCALMAIN
+        bl _FPC_haltproc
+.L_bss_start:
+        .long _bss_start
+.L_bss_end:
+        .long _bss_end
+.L_stack_top:
+        .long _stack_top
+        .text
+      end;
+
+end.
Index: rtl/embedded/arm/thumb2_bare.pp
===================================================================
--- rtl/embedded/arm/thumb2_bare.pp	(revision 0)
+++ rtl/embedded/arm/thumb2_bare.pp	(revision 0)
@@ -0,0 +1,142 @@
+
+unit thumb2_bare;
+
+{$goto on}
+{$define stm32f103}
+
+interface
+
+implementation
+
+var
+    _data: record end; external name '_data';
+    _edata: record end; external name '_edata';
+    _etext: record end; external name '_etext';
+    _bss_start: record end; external name '_bss_start';
+    _bss_end: record end; external name '_bss_end';
+    _stack_top: record end; external name '_stack_top';
+
+procedure PASCALMAIN; external name 'PASCALMAIN';
+
+procedure _FPC_haltproc; assembler; nostackframe; public name '_haltproc';
+asm
+.Lhalt:
+    b .Lhalt
+end;
+
+procedure _FPC_start; assembler; nostackframe;
+label _start;
+asm
+    .init
+    .balign 16
+
+    .long _stack_top            // stack top address
+    .long _start+1              // 1 Reset
+    .long .LDefaultHandler+1    // 2 NMI
+    .long .LDefaultHandler+1    // 3 HardFault
+    .long .LDefaultHandler+1    // 4 MemManage
+    .long .LDefaultHandler+1    // 5 BusFault
+    .long .LDefaultHandler+1    // 6 UsageFault
+    .long .LDefaultHandler+1    // 7 RESERVED
+    .long .LDefaultHandler+1    // 8 RESERVED
+    .long .LDefaultHandler+1    // 9 RESERVED
+    .long .LDefaultHandler+1    // 10 RESERVED
+    .long .LDefaultHandler+1    // 11 SVCall
+    .long .LDefaultHandler+1    // 12 Debug Monitor
+    .long .LDefaultHandler+1    // 13 RESERVED
+    .long .LDefaultHandler+1    // 14 PendSV
+    .long .LDefaultHandler+1    // 15 SysTick
+    .long .LDefaultHandler+1    // 16 External Interrupt(0)
+    .long .LDefaultHandler+1    // 17 External Interrupt(1)
+    .long .LDefaultHandler+1    // 18 External Interrupt(2)
+    .long .LDefaultHandler+1    // 19 ...
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+    .long .LDefaultHandler+1
+
+    .globl _start
+    .text
+_start:
+
+    // Copy initialized data to ram
+    ldr r1,.L_etext
+    ldr r2,.L_data
+    ldr r3,.L_edata
+.Lcopyloop:
+    cmp r2,r3
+    ittt ls
+    ldrls r0,[r1],#4
+    strls r0,[r2],#4
+    bls .Lcopyloop
+
+    // clear onboard ram
+    ldr r1,.L_bss_start
+    ldr r2,.L_bss_end
+    mov r0,#0
+.Lzeroloop:
+    cmp r1,r2
+    itt ls
+    strls r0,[r1],#4
+    bls .Lzeroloop
+
+    b PASCALMAIN
+    b _FPC_haltproc
+
+.L_bss_start:
+    .long _bss_start
+.L_bss_end:
+    .long _bss_end
+.L_etext:
+    .long _etext
+.L_data:
+    .long _data
+.L_edata:
+    .long _edata
+.LDefaultHandlerAddr:
+    .long .LDefaultHandler
+    // default irq handler just returns
+.LDefaultHandler:
+    mov pc,r14
+end;
+
+end.
+
Index: rtl/embedded/Makefile.fpc
===================================================================
--- rtl/embedded/Makefile.fpc	(revision 18871)
+++ rtl/embedded/Makefile.fpc	(working copy)
@@ -49,11 +49,15 @@
 
 ifeq ($(ARCH),arm)
 ifeq ($(SUBARCH),armv7m)
-CPU_UNITS=lm3fury lm3tempest stm32f103 # thumb2_bare 
+CPU_UNITS=lm3fury lm3tempest stm32f103 mbed thumb2_bare 
 endif
 
+ifeq ($(SUBARCH),armv4)
+CPU_UNITS=lpc21x4 at91sam7x256 arm_bare
+endif
+
 ifeq ($(SUBARCH),armv4t)
-CPU_UNITS=lpc21x4 at91sam7x256
+CPU_UNITS=lpc21x4 at91sam7x256 arm_bare
 endif
 endif
 
Index: rtl/embedded/Makefile
===================================================================
--- rtl/embedded/Makefile	(revision 18871)
+++ rtl/embedded/Makefile	(working copy)
@@ -315,10 +315,13 @@
 SYSINIT_UNITS=
 ifeq ($(ARCH),arm)
 ifeq ($(SUBARCH),armv7m)
-CPU_UNITS=lm3fury lm3tempest stm32f103 # thumb2_bare 
+CPU_UNITS=lm3fury lm3tempest stm32f103 mbed thumb2_bare 
 endif
+ifeq ($(SUBARCH),armv4)
+CPU_UNITS=lpc21x4 at91sam7x256 arm_bare
+endif
 ifeq ($(SUBARCH),armv4t)
-CPU_UNITS=lpc21x4 at91sam7x256
+CPU_UNITS=lpc21x4 at91sam7x256 arm_bare
 endif
 endif
 ifeq ($(ARCH),avr)
Index: compiler/arm/cpuinfo.pas
===================================================================
--- compiler/arm/cpuinfo.pas	(revision 18871)
+++ compiler/arm/cpuinfo.pas	(working copy)
@@ -61,6 +61,8 @@
    tcontrollertype =
      (ct_none,
 
+      ct_armbare,
+
       { Phillips }
       ct_lpc2114,
       ct_lpc2124,
@@ -149,6 +151,7 @@
       ct_lm3s9b95,
       ct_lm3s9b96,
 
+      ct_mbed,
       // generic Thumb2 target
       ct_thumb2bare
      );
@@ -213,6 +216,17 @@
    	),
 
         (
+        controllertypestr:'ARM_BARE';
+        controllerunitstr:'ARM_BARE';
+        interruptvectors:8;
+        flashbase:$00000000;
+        flashsize:$00000000;
+        srambase:$D6000000;
+        sramsize:$0000C000
+        ),
+
+
+        (
     	controllertypestr:'LPC2114';
         controllerunitstr:'LPC21x4';
         interruptvectors:8;
@@ -960,6 +974,18 @@
         srambase:$20000000;
         sramsize:$00010000
         ),
+
+        // ct_mbed
+        (
+        controllertypestr:'MBED';
+        controllerunitstr:'MBED';
+        interruptvectors:12;
+        flashbase:$00000000;
+        flashsize:$00040000;
+        srambase:$10000000;
+        sramsize:$00008000
+        ),
+
         // bare bones Thumb2
         (
     	controllertypestr:'THUMB2_BARE';
Index: compiler/systems/t_embed.pas
===================================================================
--- compiler/systems/t_embed.pas	(revision 18871)
+++ compiler/systems/t_embed.pas	(working copy)
@@ -221,6 +221,7 @@
       ct_none:
            begin
            end;
+      ct_armbare,
       ct_lpc2114,
       ct_lpc2124,
       ct_lpc2194,
@@ -304,6 +305,7 @@
       ct_lm3s9b92,
       ct_lm3s9b95,
       ct_lm3s9b96,
+      ct_mbed,
       ct_thumb2bare:
         begin
          with embedded_controllers[current_settings.controllertype] do
@@ -313,16 +315,19 @@
               Add('MEMORY');
               Add('{');
 
+              if(flashsize<>0) then
+              begin
               LinkStr := '    flash : ORIGIN = 0x' + IntToHex(flashbase,8)
-                + ', LENGTH = ' + IntToStr(flashsize div 1024)+'K';
+                  + ', LENGTH = 0x' + IntToHex(flashsize,8);
               Add(LinkStr);
+              end;
 
               LinkStr := '    ram : ORIGIN = 0x' + IntToHex(srambase,8)
-              	+ ', LENGTH = ' + IntToStr(sramsize div 1024)+'K';
+                + ', LENGTH = 0x' + IntToHex(sramsize,8);
               Add(LinkStr);
 
               Add('}');
-              Add('_stack_top = 0x' + IntToHex(sramsize+srambase-4,8) + ';');
+              Add('_stack_top = 0x' + IntToHex(sramsize+srambase,8) + ';');
             end;
         end
     else
@@ -330,6 +335,7 @@
       	 internalerror(200902011);
   end;
 
+  with embedded_controllers[current_settings.controllertype] do
   with linkres do
     begin
       Add('SECTIONS');
@@ -342,14 +348,28 @@
       Add('    *(.rodata, .rodata.*)');
       Add('    *(.comment)');
       Add('    _etext = .;');
+      if(flashsize<>0) then
+        begin
       Add('    } >flash');
+        end
+      else
+        begin
+          Add('    } >ram');
+        end;
       Add('    .data :');
       Add('    {');
       Add('    _data = .;');
       Add('    *(.data, .data.*)');
       Add('    KEEP (*(.fpc .fpc.n_version .fpc.n_links))');
       Add('    _edata = .;');
+      if(flashsize<>0) then
+        begin
       Add('    } >ram AT >flash');
+        end
+      else
+        begin
+          Add('    } >ram');
+        end;
       Add('    .bss :');
       Add('    {');
       Add('    _bss_start = .;');
